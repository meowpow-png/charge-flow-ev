---
title: "Project Roadmap"
tags: [docs, roadmap]
---

## Day 1 — Project Definition & Documentation

**Goal:**

The project intent, scope, and constraints are fully defined and documented.

**To-Do:**

- Define and lock project intent and success criteria
- Define explicit scope and non-goals
- Draft README describing the problem, system boundaries, and evaluation paths
- Define core domain concepts and terminology
- Create initial development journal entry documenting key decisions
- Establish repository structure (modules, packages, documentation layout)

**Explicit Non-Goals:**

- No application code beyond project scaffolding
- No business logic or domain behavior
- No infrastructure setup beyond repository structure

**Definition of Done:**

- README clearly defines system purpose, non-goals, and evaluation paths
- Domain concepts are documented and consistently named
- Project scope and constraints are fixed and written down
- Repository structure supports the planned backend and simulation client

**Outcome:**

Implementation can begin on Day 2 with no unresolved questions about
scope, terminology, or project direction.

## Day 2 — Backend Skeleton & Persistence Baseline

**Goal:**

The backend can accept basic session-related API calls and persist domain data reliably.

**To-Do:**

- Create Spring Boot application skeleton
- Configure PostgreSQL using Docker and JPA
- Define core domain entities *without lifecycle or business logic*
- Implement basic create/read REST endpoints for sessions
- Persist and retrieve entities successfully via JPA
- Manually verify persistence and retrieval using Swagger UI

**Explicit Non-Goals:**

- No billing calculations
- No lifecycle state transitions
- No analytics or aggregations
- No domain events beyond basic persistence callbacks

**Definition of Done:**

- Application starts without errors
- Database schema is generated or migrated successfully
- At least one session can be created and retrieved via REST

**Outcome:**

A reviewer can start the application, create a ride or charging session via Swagger,
and verify that the data is correctly stored and retrieved from the database.

## Day 3 — Analytics & Deterministic Derivations

**Goal:**

Derived business data (billing and usage metrics) can be calculated deterministically
from persisted session data and exposed via read-only APIs.

**To-Do:**

- Implement deterministic billing calculations based on persisted sessions
- Implement aggregation logic for usage metrics (e.g. energy, cost, counts)
- Expose read-only analytics endpoints
- Add focused unit tests for billing and calculation logic
- Manually verify deterministic results via repeated executions

**Explicit Non-Goals:**

- No data visualization or dashboards
- No real-time or streaming analytics
- No complex query optimization
- No external reporting or export formats

**Definition of Done:**

- Given the same persisted input data, analytics endpoints always return the same results
- Billing calculations are covered by unit tests
- Analytics endpoints are read-only and side-effect free
- Aggregated values can be explained directly from stored session data

**Outcome:**

A reviewer can inspect analytics endpoints and clearly understand how
raw session data translates into billing and usage metrics.

## Day 4 — Simulation Client & Telemetry Ingestion

**Goal:**

An external client can emit ride and charging telemetry via REST APIs,
and the backend ingests and processes this data correctly.

**To-Do:**

- Create a minimal LibGDX simulation client
- Implement HTTP communication with backend REST endpoints
- Emit ride telemetry events
- Emit charging session completion
- Execute one complete ride → charging → billing flow via the client
- Verify backend ingestion using analytics and read-only endpoints

**Explicit Non-Goals:**

- No gameplay mechanics or UI polish
- No real-time synchronization or streaming
- No bidirectional communication
- No client-side business logic or calculations

**Definition of Done:**

- Simulation client can run independently of the backend
- Telemetry sent by the client is persisted by the backend
- Backend analytics reflect data generated by the client
- No backend logic depends on the simulation client being present

**Outcome:**

The system demonstrates a full end-to-end flow using externally generated telemetry,
while remaining fully inspectable without the simulation client.

## Day 5 — Polish, Hardening & Demo Readiness

**Goal:**

The project can be evaluated confidently by an external reviewer with minimal setup
and no guidance from the author.

**To-Do:**

- Review and finalize README and documentation for clarity and accuracy
- Clean up code structure, naming, and package boundaries
- Remove dead code, TODOs, and experimental artifacts
- Verify fresh setup from a clean clone
- Validate all supported inspection paths
- Execute and verify the full end-to-end flow

**Explicit Non-Goals:**

- No new features or functionality
- No architectural refactors
- No performance tuning or optimization
- No cosmetic UI improvements

**Definition of Done:**

- Project can be cloned, built, and run without manual intervention
- Demo instructions are accurate and complete
- All inspection paths work as documented
- End-to-end flow produces correct and explainable results

**Outcome:**

A reviewer can run the project, inspect persisted data and analytics,
and understand the system’s behavior and value without additional explanation.